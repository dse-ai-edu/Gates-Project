<!doctype html>
<html lang="en">

<head>
	<title>Automatic Feedback Generation Tool</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

	<link href='https://fonts.googleapis.com/css?family=Roboto:400,100,300,700' rel='stylesheet' type='text/css'>

	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

	<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/style.css') }}">
	<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/fileinput.css') }}">

	<script>
		window.onload = function () {
			loadSection();
		};
	</script>

</head>

<body>
	<div id="colorlib-page">
		<a href="#" class="js-colorlib-nav-toggle colorlib-nav-toggle"><i></i></a>
		<aside id="colorlib-aside" role="complementary" class="js-fullheight">
			<nav id="colorlib-main-menu" role="navigation">
				<ul>
					<h3>Build Feedback System</h3>
					<li><a href="#" data-content="base_style">Base Style and Feedback Template</a></li>
					<li><a href="#" data-content="macro_feedback">Teaching Style and Personalization</a></li>
					<br>
					<h3>Generate Feedback</h3>
					<li><a href="#" data-content="answer">Answer</a></li>
					<li><a href="#" data-content="feedback">Feedback</a></li>
				</ul>
			</nav>
		</aside> <!-- END COLORLIB-ASIDE -->

		<div id="colorlib-main">
		</div><!-- END COLORLIB-MAIN -->
	</div><!-- END COLORLIB-PAGE -->

	</section>

	<script src="{{ url_for('static', filename='js/jquery.min.js') }}"></script>
	<script src="{{ url_for('static', filename='js/popper.js') }}"></script>
	<script src="{{ url_for('static', filename='js/bootstrap.min.js') }}"></script>
	<script src="{{ url_for('static', filename='js/main.js') }}"></script>
	<script src="{{ url_for('static', filename='js/fileinput.js') }}"></script>
	<script src="https://cdn.jsdelivr.net/npm/diff@5.2.0/dist/diff.min.js"></script>

	<script>
		document.addEventListener("DOMContentLoaded", function () {
			const menuLinks = document.querySelectorAll("#colorlib-main-menu a");

			menuLinks.forEach(link => {
				link.addEventListener("click", function (e) {
					e.preventDefault();
					let tid = sessionStorage.getItem('tid');
					let section = this.getAttribute("data-content");
					// we may change the way in this for reducing the request frequency to the mongodb
					fetch('/api/section/load', {
						method: 'POST', 
						headers: {
							'Content-Type': 'application/json'
						}, 
						body: JSON.stringify({'tid':tid,'section':section})
					}).then(res => res.json()).then(data => {
						if (data.info) {
							if (data.info.text) {
								window.location.href = `/create?section=${encodeURIComponent(section)}&input=text`		
							} else {
								window.location.href = `/create?section=${encodeURIComponent(section)}`
							}
						} else {
							window.location.href = `/create?section=${encodeURIComponent(section)}`
						}
					})
				});
			});
		});
	</script>

	<script>
		function taskReload() {
			const mainPanel = document.getElementById("colorlib-main");
			// the idea is that based on the needed results, we can judge which is good (Text or File)
			// everytime you click something, then the system is saving that task into the database.
			// @ Luke, you may help me on it to load the contents
		}

		function collectInfo() {
			let url = new URL(window.location.href);
			let tid = sessionStorage.getItem('tid');
			let input = url.searchParams.get('input');
			let section = url.searchParams.get('section');

			if (section=='base_style') {
				let selectedStyles = getSelectedStyles();
				let templateTexts = getTemplateTexts();
				return {'tid':tid, 'base_style': {'styles': selectedStyles, 'templates': templateTexts}};
			} else if (section=='macro_feedback') {
				let teachingStyle = getSelectedTeachingStyle();
				let additionalInstructions = getAdditionalInstructions();
				return {'tid':tid, 'macro_feedback': {'teaching_style': teachingStyle, 'instructions': additionalInstructions}};
			} else if (input=='text') {
				let sectInfo = document.getElementById('sect-info').value;
				return {'tid':tid, [section]: {'text':sectInfo}};
			} else if (input=='file') {
				return {'tid':tid, [section]: null};
			} else {
				return {'tid':tid, [section]: null};
			}
		}

		function restoreInfo() {
			let url = new URL(window.location.href);
			let tid = sessionStorage.getItem('tid')
			if (tid!=null) {
				let input = url.searchParams.get('input');
				let section = url.searchParams.get('section');

				fetch(`/api/section/load`, {
					method: 'POST', 
					headers: {
						'Content-Type': 'application/json'
					}, 
					body: JSON.stringify({'tid':tid,'section':section})
				}).then(response => {
					if (!response.ok) {
						throw Error('Fail to load section content.');
					}
					return response.json()
				}).then(result => {
					if (section=='base_style') {
						if (result.info && result.info.styles) {
							// Restore selected style descriptors
							result.info.styles.forEach(style => {
								const checkbox = document.getElementById(style);
								if (checkbox) checkbox.checked = true;
							});
						}
						if (result.info && result.info.templates) {
							// Restore template texts
							const templateInputs = document.querySelectorAll('.template-input');
							result.info.templates.forEach((template, index) => {
								if (templateInputs[index]) {
									templateInputs[index].value = template;
								}
							});
						}
					} else if (section=='macro_feedback') {
						if (result.info && result.info.teaching_style) {
							// Restore selected teaching style
							const radio = document.querySelector(`input[name="teaching-style"][value="${result.info.teaching_style}"]`);
							if (radio) radio.checked = true;
						}
						if (result.info && result.info.instructions) {
							// Restore additional instructions
							const textarea = document.getElementById('additional-instructions');
							if (textarea) textarea.value = result.info.instructions;
						}
					} else if (input=='text') {
						if (result.info && result.info['text']) {
							document.getElementById('sect-info').value = result.info['text'];
						}
					}				
				}).catch(error => {
					console.error(error)
				})
			}
		}

		function saveSection() {
			let url = new URL(window.location.href);
			let input = url.searchParams.get('input');
			let section = url.searchParams.get('section');
			
			let sectInfo = collectInfo();
			if (section=="base_style" || section=="macro_feedback") {

				// Validation for base_style section
				if (section=="base_style") {
					const selectedStyles = getSelectedStyles();
					const templateTexts = getTemplateTexts();
					if (selectedStyles.length === 0) {
						alert("â— Please select at least one style descriptor.");
						return;
					}
					if (templateTexts.length === 0) {
						alert("â— Please enter at least one feedback template item.");
						return;
					}
				}

				// Validation for macro_feedback section  
				if (section=="macro_feedback") {
					const teachingStyle = getSelectedTeachingStyle();
					if (!teachingStyle) {
						alert("â— Please select a teaching style.");
						return;
					}
				}

				fetch(`/api/section/save`, {
					method: 'POST', headers: {
						'Content-Type': 'application/json'
					}, 
					body: JSON.stringify(sectInfo)
				}).then(response => {
					if (!response.ok) {
						throw Error('Save failed! Please try again.');
					}
					return response.json()
				}).then(result => {
					if (result.success) {
						// Show success message
						const status = document.getElementById('save-status') || document.getElementById('info-message');
						if (status) {
							const originalText = status.textContent;
							status.textContent = 'âœ”ï¸ Saved';
							status.style.color = 'green';
							
							// Clear status when user makes changes
							const clearStatus = () => {
								status.textContent = originalText;
								status.style.color = '';
							};
							
							// Add event listeners to clear status on change
							if (section == "base_style") {
								document.querySelectorAll('input[type="checkbox"], .template-input').forEach(input => {
									input.addEventListener('change', clearStatus, {once: true});
								});
							} else if (section == "macro_feedback") {
								document.querySelectorAll('input[type="radio"], #additional-instructions').forEach(input => {
									input.addEventListener('change', clearStatus, {once: true});
								});
							}
						}
					} else {
						throw Error('Save failed! Please try again.');
					}
				}).catch(error => {
					console.error(error)
					alert(error)
				})

			} else {

				//addition below// does not allow an empty save
				if (input === 'text') {
					const text = document.getElementById('sect-info').value.trim();
					if (!text) {
						alert("â— Cannot save an empty response. Please enter some text.");
						return;
					}
				}
				//  //

				fetch(`/api/section/save`, {
					method: 'POST', headers: {
						'Content-Type': 'application/json'
					}, 
					body: JSON.stringify(sectInfo)
				}).then(response => {
					if (!response.ok) {
						throw Error('Save failed! Please try again.');
					}
					return response.json()
				}).then(result => {
					if (result.success) {
						//addition below//  save/check mark appears after a succesful save
						//alert('Save succeed! Please proceed to the next step.');
						
						//gets needed elements
						const infoMessage = document.getElementById('info-message');
						const originalText = infoMessage.textContent;
						
						//updates message when succesfully saved
						infoMessage.textContent = 'âœ”ï¸ Saved';
						infoMessage.style.color = 'green';

						const sectInput = document.getElementById('sect-info');
						
						//when user makes an edit, original message is restored
						const clearStatus = () => {
							infoMessage.textContent = originalText;
							infoMessage.style.color = '';
							sectInput.removeEventListener('input', clearStatus);
						};

						sectInput.addEventListener('input', clearStatus);
					//  //

					} else {
						throw Error('Save failed! Please try again.');
					}
				}).catch(error => {
					console.error(error)
					alert(error)
				})
			}
		}

		function resetSection() {
			let url = new URL(window.location.href);
			let input = url.searchParams.get('input');
			let section = url.searchParams.get('section');
			if (section=="base_style") {
				// Reset style descriptors
				document.querySelectorAll('#style-grid input[type="checkbox"]').forEach(checkbox => {
					checkbox.checked = false;
				});
				// Reset template inputs
				document.querySelectorAll('.template-input').forEach(input => {
					input.value = '';
				});
			} else if (section=="macro_feedback") {
				// Reset teaching style selection
				document.querySelectorAll('input[name="teaching-style"]').forEach(radio => {
					radio.checked = false;
				});
				// Reset additional instructions
				const textarea = document.getElementById('additional-instructions');
				if (textarea) textarea.value = '';
			} else if (input=='text') {
				document.getElementById('sect-info').value = '';
			}
		}

		function updateContent(template) {
			let url = new URL(window.location.href);
			let input = url.searchParams.get('input');
			let section = url.searchParams.get('section');
			let optid = url.searchParams.get('optid');
			
			// Map sections to their corresponding templates
			if (section == 'base_style') {
				template = 'feedback_step1';
			} else if (section == 'macro_feedback') {
				template = 'feedback_step2';
			}
			
			fetch(`/static/html/${template}.html`).then(
				response => response.text()
			).then(html => {
				const parser = new DOMParser();
				const shadow = parser.parseFromString(html, 'text/html');
				document.getElementById('colorlib-main').innerHTML = shadow.getElementById('colorlib-main').innerHTML;
				if (section == 'answer' && input=='text') {
					document.getElementById('save-btn').textContent = 'Generate';
					document.getElementById('save-btn').setAttribute('id', 'generate-btn');
					document.getElementById('next-btn').remove();
				}
			}).then(() => {
				updateHandler();
			}).then(() => {
				if (section=='feedback') {
					loadFeedback();
				} else {
					// restore the contents from the databse
					restoreInfo();
				}				
			});
		};

		function updateHandler() {
			const tid = sessionStorage.getItem('tid')
			const url = new URL(window.location.href);
			const input = url.searchParams.get('input');
			const section = url.searchParams.get('section')
			
			if (document.getElementById('text-btn')) {
				document.getElementById('text-btn').addEventListener('click', function () {
					url.searchParams.set('input', 'text');
					window.location.href = url.toString();
				})
			}

			if (document.getElementById('file-btn')) {
				document.getElementById('file-btn').addEventListener('click', function () {
					url.searchParams.set('input', 'file');
					window.location.href = url.toString();
				})
			}

			if (document.getElementById('back-btn')) {
				document.getElementById('back-btn').addEventListener('click', function () {
					if (section=='answer' && input==null) {
						window.location.href = '/select'
					} else if (input) {
						// for the page with input, the back is always get it back to the 
						url.searchParams.delete('input');
						window.location.href = url.toString();
					} else {
						let prevSibling = document.querySelector(`[data-content=${section}]`).parentNode.previousElementSibling;
						while (prevSibling) {
							if (prevSibling.firstElementChild) {
								let prevSection = prevSibling.firstElementChild.getAttribute('data-content');
								// we may change the way in this for reducing the request frequency to the mongodb
								fetch('/api/section/load', {
									method: 'POST', 
									headers: {
										'Content-Type': 'application/json'
									}, 
									body: JSON.stringify({'tid':tid,'section':prevSection})
								}).then(res => res.json()).then(data => {
									if (data.info) {
										if (data.info.text) {
											window.location.href = `/create?section=${encodeURIComponent(prevSection)}&input=text`;
										} else {
											window.location.href = `/create?section=${encodeURIComponent(prevSection)}`;
										}
									} else {
										window.location.href = `/create?section=${encodeURIComponent(prevSection)}`;
									}
								})
								break;
							}
							prevSibling = prevSibling.previousElementSibling;
						}
					}
				})
			}

			if (document.getElementById('next-btn')) {
				document.getElementById('next-btn').addEventListener('click', function () {
					// Validation for feedback generation steps
					if (section === 'base_style') {
						const selectedStyles = getSelectedStyles();
						const templateTexts = getTemplateTexts();
						if (selectedStyles.length === 0) {
							alert("â— Please select at least one style descriptor before proceeding.");
							return;
						}
						if (templateTexts.length === 0) {
							alert("â— Please enter at least one feedback template item before proceeding.");
							return;
						}
					}
					
					if (section === 'macro_feedback') {
						const teachingStyle = getSelectedTeachingStyle();
						if (!teachingStyle) {
							alert("â— Please select a teaching style before proceeding.");
							return;
						}
					}

					let nextSibling = document.querySelector(`[data-content=${section}]`).parentNode.nextElementSibling;
					
					while (nextSibling) {
						if (nextSibling.firstElementChild) {
							let nextSection = nextSibling.firstElementChild.getAttribute('data-content');
							fetch('/api/section/load', {
								method: 'POST', 
								headers: {
									'Content-Type': 'application/json'
								}, 
								body: JSON.stringify({'tid':tid,'section':nextSection})
							}).then(res => res.json()).then(data => {
								if (data.info) {
									if (data.info.text) {
										window.location.href = `/create?section=${encodeURIComponent(nextSection)}&input=text`;
									} else {
										window.location.href = `/create?section=${encodeURIComponent(nextSection)}`;
									}
								} else {
									window.location.href = `/create?section=${encodeURIComponent(nextSection)}`;
								}
							})
							break;
						}
						nextSibling = nextSibling.nextElementSibling;
					}
				})
			}

			// add the action attached to the button
			if (document.getElementById('save-btn')) {
				document.getElementById('save-btn').addEventListener('click', function () {
					saveSection();
				})
			}

			if (document.getElementById('reset-btn')) {
				document.getElementById('reset-btn').addEventListener('click', function () {
					resetSection();
				})
			}

			if (document.getElementById('generate-btn')) {
				document.getElementById('generate-btn').addEventListener('click', function () {
					submitAnswer();
				})
			}

			if (document.getElementById('drop-area')) {
				const dropArea = document.getElementById('drop-area');
				dropArea.addEventListener('dragover', e => {
					e.preventDefault();
					dropArea.style.background = '#e3f2fd';
				});

				dropArea.addEventListener('dragleave', () => {
					dropArea.style.background = '#fafafa';
				});

				dropArea.addEventListener('drop', e => {
					e.preventDefault();
					dropArea.style.background = '#fafafa';
					handleFiles(e.dataTransfer.files);
				});
			}

			if (document.getElementById('fileElem')) {
				fileElem.addEventListener('change', () => {
					handleFiles(fileElem.files);
				});
			}
		}

		function submitAnswer() {
			let url = new URL(window.location.href);
			let aid = crypto.randomUUID();
			let tid = sessionStorage.getItem('tid');
			let input = url.searchParams.get('input');
			if (input=='text') {
				let answer = document.getElementById('sect-info').value;
				fetch(`/api/answer/submit`, {
					method: 'POST', headers: {
						'Content-Type': 'application/json'
					}, 
					body: JSON.stringify({'aid':aid,'tid':tid,'answer_text':answer})
				});
				// for now we will only redirect the page for the text inputs
				window.location.href = `/create?section=feedback&aid=${aid}`;
			}
		}

		function loadFeedback() {
			let url = new URL(window.location.href);
  			let aid = url.searchParams.get('aid');
			
			const container = document.getElementById("feedback-content");
			if (aid==null) {
				container.textContent = "Please step back and submit the answer first.";
				return
			}
			container.textContent = "ðŸ”„ Generating feedback...";
			
			let attempts = 0;
			const interval = setInterval(() => {
				fetch(`/api/feedback/load?aid=${aid}`)
				.then(res => res.json())
				.then(data => {
					if (data.grade) {
					// container.textContent = data.grade;
					container.innerHTML = data.grade;
					clearInterval(interval);
					} else if (++attempts > 5) {
					container.textContent = "âš ï¸ Feedback generation timed out. Please step back and submit the answer again.";
					clearInterval(interval);
					}
				});
			}, 2000); // Poll every 2 seconds
		}

		function loadSection() {
			let url = new URL(window.location.href);
			let input = url.searchParams.get('input');
			let section = url.searchParams.get('section');
			
			document.querySelectorAll("#colorlib-main-menu li").forEach(li => li.classList.remove("colorlib-active"));
			document.querySelector(`[data-content=${section}]`).parentElement.classList.add("colorlib-active");

			let selectSection = ['answer'];
			if (selectSection.includes(section)) {
				if (input == "text") {
					updateContent('textinput');
				} else if (input == "file") {
					updateContent('fileinput');
				} else {
					updateContent('innavi');
				}
			} else if (section=='base_style') {
				updateContent('feedback_step1');
			} else if (section=='macro_feedback') {
				updateContent('feedback_step2');
			} else if (section=='feedback') {
				updateContent('feedback');
			} else {
				document.getElementById('colorlib-main').innerHTML = ""
			}
		}

		// Escape HTML for safe display
		function escapeHtml(text) {
			return text.replace(/[&<>"']/g, function(m) {
				return ({
					'&': '&amp;',
					'<': '&lt;',
					'>': '&gt;',
					'"': '&quot;',
					"'": '&#039;'
				})[m];
			});
		}
	</script>

</body>

</html>